{"version":3,"sources":["webpack://NamingConventions/webpack/universalModuleDefinition","webpack://NamingConventions/webpack/bootstrap","webpack://NamingConventions/webpack/runtime/define property getters","webpack://NamingConventions/webpack/runtime/hasOwnProperty shorthand","webpack://NamingConventions/./src/naming-conventions.ts"],"names":["root","factory","exports","module","define","amd","window","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","conventions","camelCase","from","input","parsedInput","regex","to","letter","toUpperCase","pascalCase","toLowerCase","substring","postProcess","result","snakeCase","kebabCase","NamingConventions","convert","convention","_getConvention","targetConvention","_replace","len","length","parsed","prevType","stack","i","type","char","isNaN","parseInt","_compareTypes","push","join","conventionName","processor","Error","replace","match"],"mappings":"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","file":"naming-conventions.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"NamingConventions\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NamingConventions\"] = factory();\n\telse\n\t\troot[\"NamingConventions\"] = factory();\n})(window, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * JavaScript naming conventions conversion\n * (c) 2020-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\nconst TYPE_NUMBER = 1, TYPE_LOWERCASE = 2, TYPE_UPPERCASE = 3, TYPE_SPECIAL = 4;\n\nexport interface NamingConventionProcessor {\n    from: (input: string) => { parsedInput: string, regex: RegExp },\n    to: (letter: string) => string,\n    postProcess?: (result: string) => string\n}\n\nconst conventions: {[convention: string]: NamingConventionProcessor} = {\n    camelCase: {\n        from(input) {\n            return {\n                parsedInput: input,\n                regex: /[A-Z]/g\n            }\n\n        },\n        to(letter) {\n            return letter.toUpperCase();\n        }\n    },\n    pascalCase: {\n        from(input) {\n            const parsedInput = input[0].toLowerCase() + input.substring(1);\n            return {\n                parsedInput,\n                regex: /[A-Z]/g\n            }\n\n        },\n        to(letter) {\n            return letter.toUpperCase();\n        },\n        postProcess(result) {\n            return result[0].toUpperCase() + result.substring(1);\n        }\n    },\n    snakeCase: {\n        from(input) {\n            return {\n                parsedInput: input,\n                regex: /_[a-z]/g\n            }\n        },\n        to(letter) {\n            return `_${letter.toLowerCase()}`;\n        }\n    },\n    kebabCase: {\n        from(input) {\n            return {\n                parsedInput: input,\n                regex: /-[a-z]/g\n            }\n        },\n        to(letter) {\n            return `-${letter.toLowerCase()}`;\n        }\n    }\n};\n\nexport type NamingConvention = keyof typeof conventions;\n\nexport const NamingConventions = {\n    camelCase: 'camelCase',\n    pascalCase: 'pascalCase',\n    snakeCase: 'snakeCase',\n    kebabCase: 'kebabCase',\n    convert(input: string) {\n        return {\n            /**\n             * Prepare provided input to be converted from given convention\n             */\n            from(convention: NamingConvention): { to: (targetConvention: NamingConvention) => string } {\n                const {parsedInput, regex} = _getConvention(convention).from(input);\n                return {\n                    to(targetConvention: NamingConvention): string {\n                        return _replace(parsedInput, regex, targetConvention);\n                    }\n                }\n            },\n            /**\n             * Parse provided input and convert it to desired convention\n             */\n            to(targetConvention: NamingConvention): string {\n                const len = input.length,\n                    parsed = [];\n                let prevType = 0,\n                    stack = '';\n\n                for (let i = 0; i < len; i++) {\n                    const type = _getType(input[i]);\n\n                    if (i > 0 && !_compareTypes(prevType, type, stack) && stack.length) {\n                        parsed.push(stack);\n                        stack = '';\n                    }\n\n                    if (i === 0 || type !== TYPE_SPECIAL) {\n                        stack += input[i].toLowerCase();\n                    }\n\n                    prevType = type;\n                }\n\n                if (stack.length) {\n                    parsed.push(stack);\n                }\n\n                return _replace(parsed.join('-'), /-[a-z]/g, targetConvention);\n            }\n        }\n    },\n    /**\n     * @param {string} conventionName\n     * @param {NamingConventionProcessor} processor\n     */\n    addConvention(conventionName: string, processor: NamingConventionProcessor): void {\n        conventions[conventionName] = processor;\n        NamingConventions[conventionName] = conventionName;\n    }\n};\n\nexport default NamingConventions;\n\nfunction _getConvention(convention: NamingConvention): NamingConventionProcessor {\n    if (typeof conventions[convention] !== 'undefined') {\n        return conventions[convention];\n    }\n    throw new Error(`Unknown naming convention '${convention}'!`)\n}\n\nfunction _replace(parsedInput: string, regex: RegExp, targetConvention: NamingConvention): string {\n    const result = parsedInput.replace(regex, (match) => {\n        return _getConvention(targetConvention).to(match.substring(match.length - 1));\n    });\n    if (result.length && typeof _getConvention(targetConvention).postProcess === 'function') {\n        return _getConvention(targetConvention).postProcess(result);\n    }\n    return result;\n}\n\nfunction _getType(char: string): number {\n    if (!isNaN(parseInt(char, 10))) {\n        return TYPE_NUMBER;\n    } else if (char === char.toLowerCase() && char !== char.toUpperCase()) {\n        return TYPE_LOWERCASE;\n    } else if (char === char.toUpperCase() && char !== char.toLowerCase()) {\n        return TYPE_UPPERCASE;\n    }\n    return TYPE_SPECIAL;\n}\n\nfunction _compareTypes(prevType: number, type: number, stack: string): boolean {\n    if (type === prevType) {\n        return true;\n    } else if (type === TYPE_NUMBER) {\n        return prevType !== TYPE_SPECIAL;\n    } else if (type === TYPE_LOWERCASE && prevType === TYPE_UPPERCASE) {\n        return stack.length === 1; // for camelCase\n    }\n    return false;\n}\n"],"sourceRoot":""}